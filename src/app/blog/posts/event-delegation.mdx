---
title: Event delegation - The React Way
date: "2025-11-15T22:12:03.284Z"
tags:
  - react 16
  - react 17
  - event delegation
  - event bubbling
published: true
---

import { BubblingVisualizer } from "components/blog/BubblingVisualizer";
import { SynEventViewer } from "components/blog/SynEventViewer";

This article explains how event delegation works in the React DOM. We will first define the terms and show what they do in plain JavaScript; skip ahead if you already know this part.

# Event

An event is a signal sent by the browser (or your environment) to notify you that an action or behavior has occurred. You can then attach listeners to these signals so your code can react to the events.

These events fire in the browser, so their behavior depends on the browser environment rather than on native JavaScript. Fortunately, their behavior has been standardized across browsers for some time.

```javascript
const button = document.getElementById("button");

/* On which element do I listen to the event */
button.addEventListener(
  /* Type of event to listen to */
  "click",
  /* What to do when this event happens */
  () => {},
);
```

<p />

# Event bubbling

In the earlier example, we add a click listener to a button, which makes sense because the button is the element being clicked. But what if we want to detect clicks outside the button? For instance, a popover appears when you click the button, and you want it to disappear when you click anywhere else. You could attach an event listener to every element on the page, but that would quickly become unmanageable. Fortunately, events don't stop at the clicked elementâ€”they travel up and down the DOM tree.

When you interact with the pageâ€”say, by clicking an elementâ€”the click event travels from the top of the window down to the target element, then back up again. The downward journey is the **Capture** phase; the upward return is the **Bubble** phase.

<BubblingVisualizer />

## Not every event will bubble ðŸ§‹

Not all events bubble. For example, the `focus` event does not bubble. This is because the focus event fires only on the focused element itself, not on its descendants.

Scroll events also do not bubble. This is because the scroll event fires only on the scrollable element itself, not on its descendants.

## Bubbling phase

The bubbling phase is the more commonly used of the two. It flows bottom-upâ€”starting from the target element and traveling up to the root.

# Event delegation

Event delegation is a technique for listening to events on a parent element instead of the target element. This is useful when you have many elements that need to respond to the same eventâ€”a direct application of the bubbling phase.

<Playground
  initialSnippet={{
    markup: `<div id="parent">
  <button>Button 1</button>
  <button>Button 2</button>
  <button>Button 3</button>
  <button>Button 4</button>
  <button>Button 5</button>
  <button>Button 6</button>
  <button>Button 7</button>
  <button>Button 8</button>
  <button>Button 9</button>
  <button>Button 10</button>
</div>`,
    css: ``,
    javascript: `const parent = document.getElementById("parent");
parent.addEventListener("click", (event) => {
  alert("Button clicked: " + event.target.textContent);
  console.log("Event target", event.target.textContent);
  console.log("Event currentTarget", event.currentTarget.id);
});`,
  }}
  defaultEditorTab="javascript"
/>

<br />

# Synthetic Events - React's Event System

React's synthetic event system is a wrapper around the browser's event system. React creates an event object for the native event and then dispatches it to the target element.

When you listen to an event through a React element, the event object that you see is a synthetic event object. This is a wrapper around the native event object that is created by React.

<SynEventViewer />

React's custom event system started as an effort to normalize browser behavior. By managing events internally, React controls how bubbling works across all events. In fact, as mentioned earlier, even if you listen at the parent level, you'll find that the bubbled event is still a React synthetic event. (Caveat: this applies when using React event handlers.)

## How does React achieve this?

If we think about this naively, React should attach an event listener to every DOM element out there. When there are apps around with 10k DOM elements or so, this becomes a bottleneck.

But there's an interesting solution we already discussed: event bubbling. Many events naturally bubble. When React detects that a user has attached an event handler (like onClick), it adds an onClick to the root React element. Once the event bubbles up to the root, React identifies the event and its origin, then passes the same information to the original event handler (our onClick listener). This way, React has far fewer event listeners on the DOM but still handles all of them.

Try to guess the output of the document event click in the following example:

```javascript
import React, { useEffect } from "react";

function App() {
  useEffect(() => {
    const handleDocumentClick = (event) => {
      console.log("Document clicked", event);
    };
    document.addEventListener("click", handleDocumentClick);
    return () => {
      document.removeEventListener("click", handleDocumentClick);
    };
  }, []);
  useEffect(() => {
    const handleRootElClick = (event) => {
      console.log("Root El clicked", event);
    };
    const rootEl = document.getElementById("root");
    rootEl.addEventListener("click", handleRootElClick);
    return () => {
      rootEl.removeEventListener("click", handleRootElClick);
    };
  }, []);

  const handleParentClick = (event) => {
    console.log("Parent clicked", event);
    event.stopPropagation();
  };

  return (
    <div onClick={handleParentClick}>
      <button>Button</button>
    </div>
  );
}

export default App;
```

It prints the root-level element's console log, even though the React event listener calls `event.stopPropagation()`. However, it does not print the document console log if you're using React 17 or above. Why is that?

As mentioned, React attaches event listeners to the root element. Although the user calls `stopPropagation()` in the React event listener, the native event must still bubble to the root element for React to detect it. By the time the event reaches the root, the native click handler has already executed. However, the document handler has not yet run, so React can prevent it from firing.

Note that this behavior occurs because we mixed event patterns: the root element event listener is in JavaScript, not React.
